/* auto-generated by NAPI-RS */
/* eslint-disable */
/**
 * Dependency class.
 * Represents a package dependency.
 *
 * @class Dependency - The Dependency class.
 * @property {string} name - The name of the dependency.
 * @property {string} version - The version of the dependency.
 *
 * @example
 *
 * ```typescript
 * const dep = new Dependency("foo", "1.0.0");
 * console.log(dep.name); // foo
 * console.log(dep.version); // 1.0.0
 * ```
 */
export declare class Dependency {
  /**
   * Create a new dependency with a name and version
   *
   * @param {string} name - The name of the dependency package.
   * @param {string} version - The version of the dependency.
   *
   * @returns {Dependency} The new dependency.
   */
  constructor(name: string, version: string)
  /**
   * Gets the name of the dependency.
   *
   * @returns {string} The name of the dependency.
   */
  get name(): string
  /**
   * Gets the version of the dependency.
   *
   * @returns {string} The version of the dependency.
   */
  get version(): string
  /**
   * Updates dependency version
   *
   * @param {string} version - The new version of the dependency.
   */
  updateVersion(version: string): void
}

/**
 * JavaScript binding for ws_pkg::types::diff::DependencyChange
 * Represents a change in a dependency
 */
export declare class DependencyChange {
  /** Name of the dependency */
  name: string
  /** Previous version (null if newly added) */
  previousVersion?: string
  /** Current version (null if removed) */
  currentVersion?: string
  /** Type of change */
  changeType: ChangeType
  /** Whether this is a breaking change based on semver */
  breaking: boolean
  /** Create a new dependency change */
  constructor(name: string, previousVersion: string | undefined | null, currentVersion: string | undefined | null, changeType: ChangeType, breaking: boolean)
  /** Create a new dependency change from a JavaScript object */
  static fromObject(props: object): DependencyChange
  get name(): string
  get previousVersion(): string | null
  get currentVersion(): string | null
  get changeType(): ChangeType
  get breaking(): boolean
}

/** JavaScript binding for ws_pkg::graph::DependencyGraph */
export declare class DependencyGraph {
  /**
   * Check if all dependencies in the graph can be resolved internally
   *
   * @returns {boolean} True if all dependencies can be resolved within the workspace
   */
  isInternallyResolvable(): boolean
  /**
   * Find missing (unresolved) dependencies in the workspace
   *
   * @returns {string[]} Array of missing dependency names
   */
  findMissingDependencies(): Array<string>
  /**
   * Find version conflicts in the dependency graph
   *
   * @returns {Object | null} Map of dependency names to arrays of conflicting versions,
   *                         or null if no conflicts found
   */
  findVersionConflicts(): Record<string,string>|null
  /**
   * Detect circular dependencies in the graph
   *
   * @returns {string[] | null} Path of the cycle if found, null otherwise
   */
  detectCircularDependencies(): Array<string> | null
  /**
   * Get a node by its identifier
   *
   * @param {string} id - The node identifier
   * @returns {Package | null} The package if found, null otherwise
   */
  getNode(id: string): Package | null
  /**
   * Get dependents of a package
   *
   * @param {string} id - The package identifier
   * @returns {string[]} Array of package names that depend on this package
   */
  getDependents(id: string): string[]
  /**
   * Validate dependencies in the graph
   *
   * @returns {ValidationReport} A report of validation issues
   */
  validatePackageDependencies(): ValidationReport
}

/**
 * DependencyRegistry class
 * A registry to manage shared dependency instances
 *
 * @class DependencyRegistry - The DependencyRegistry class.
 * @example
 *
 * ```typescript
 * const registry = new DependencyRegistry();
 * const dep1 = registry.getOrCreate("foo", "^1.0.0");
 * const dep2 = registry.getOrCreate("bar", "^2.0.0");
 *
 * // Resolve version conflicts
 * const result = registry.resolveVersionConflicts();
 * console.log(result.resolvedVersions);
 * ```
 */
export declare class DependencyRegistry {
  /**
   * Create a new dependency registry
   *
   * @returns {DependencyRegistry} A new empty registry
   */
  constructor()
  /**
   * Get or create a dependency in the registry
   *
   * @param {string} name - The name of the dependency
   * @param {string} version - The version or version requirement
   * @returns {Dependency} The dependency instance
   */
  getOrCreate(name: string, version: string): Dependency
  /**
   * Get a dependency by name
   *
   * @param {string} name - The name of the dependency
   * @returns {Dependency | null} The dependency instance if found, null otherwise
   */
  get(name: string): Dependency | null
  /**
   * Resolve version conflicts between dependencies
   *
   * @returns {ResolutionResult} The result of dependency resolution
   */
  resolveVersionConflicts(): ResolutionResult
  /**
   * Apply a resolution result to update all dependencies
   *
   * @param {ResolutionResult} result - The resolution result to apply
   * @returns {void}
   */
  applyResolutionResult(result: ResolutionResult): void
  /**
   * Find highest version that is compatible with all requirements
   *
   * @param {string} name - The name of the dependency
   * @param {string[]} requirements - List of version requirements
   * @returns {string | null} The highest compatible version, if any
   */
  findHighestCompatibleVersion(name: string, requirements: Array<string>): string | null
}

/** JavaScript binding for ws_pkg::upgrader::DependencyUpgrader */
export declare class DependencyUpgrader {
  /**
   * Create a new dependency upgrader with default configuration
   *
   * @returns {DependencyUpgrader} A new dependency upgrader
   */
  constructor()
  /**
   * Create a new dependency upgrader with the given configuration
   *
   * @param {UpgradeConfig} config - The upgrade configuration
   * @returns {DependencyUpgrader} A new dependency upgrader
   */
  static withConfig(config: UpgradeConfig): DependencyUpgrader
  /**
   * Set the configuration for the upgrader
   *
   * @param {UpgradeConfig} config - The upgrade configuration
   */
  setConfig(config: UpgradeConfig): void
  /**
   * Check for upgrades for a single dependency
   *
   * @param {string} packageName - The name of the package containing the dependency
   * @param {Dependency} dependency - The dependency to check for upgrades
   * @returns {AvailableUpgrade} Information about available upgrades
   */
  checkDependencyUpgrade(packageName: string, dependency: Dependency): AvailableUpgrade
  /**
   * Check all dependencies in a package for available upgrades
   *
   * @param {Package} package - The package to check for upgrades
   * @returns {AvailableUpgrade[]} Array of available upgrades
   */
  checkPackageUpgrades(package: Package): AvailableUpgrade[]
  /**
   * Check all packages in a collection for available upgrades
   *
   * @param {Package[]} packages - The packages to check for upgrades
   * @returns {AvailableUpgrade[]} Array of available upgrades
   */
  checkAllUpgrades(packages: Array<Package>): AvailableUpgrade[]
  /**
   * Apply upgrades to packages based on what was found
   *
   * @param {Package[]} packages - The packages to apply upgrades to
   * @param {AvailableUpgrade[]} upgrades - The upgrades to apply
   * @returns {AvailableUpgrade[]} The upgrades that were applied
   */
  applyUpgrades(packages: Array<Package>, upgrades: Array<AvailableUpgrade>): AvailableUpgrade[]
  /**
   * Generate a report of upgrades in a human-readable format
   *
   * @param {AvailableUpgrade[]} upgrades - The upgrades to report
   * @returns {string} A human-readable report
   */
  generateUpgradeReport(upgrades: Array<AvailableUpgrade>): string
}

/**
 * Represents a node in a dependency graph
 *
 * This is a marker interface in JavaScript - the actual Node trait
 * is implemented by Package in Rust.
 */
export declare class Node {
  /**
   * Create a new Node instance
   *
   * @returns {Node} a new Node instance
   */
  constructor()
}

/** JavaScript binding for ws_pkg::Package */
export declare class Package {
  /** Create a new package with a name and version */
  constructor(name: string, version: string)
  /**
   * Create a new package with dependencies using the dependency registry
   *
   * @param {string} name - The name of the package
   * @param {string} version - The version of the package
   * @param {Array<[string, string]>} dependencies - Array of [name, version] tuples for dependencies
   * @param {DependencyRegistry} registry - The dependency registry to use
   * @returns {Package} The new package
   */
  static withRegistry(name: string, version: string, dependencies: Array<[string, string]> | undefined | null, registry: DependencyRegistry): Package
  /**
   * Get the package name
   *
   * @returns {string} The package name
   */
  get name(): string
  /**
   * Get the package version
   *
   * @returns {string} The package version
   */
  get version(): string
  /**
   * Update the package version
   *
   * @param {string} version - The new version to set
   */
  updateVersion(version: string): void
  /**
   * Get all dependencies of this package
   *
   * This method returns an array of Dependency objects that can be used in JavaScript.
   * Note: Due to technical limitations, this method requires special handling in JavaScript.
   *
   * @returns {Array<Dependency>} An array of Dependency objects
   */
  dependencies(): Array<Dependency>
  /**
   * Add a dependency to this package
   *
   * @param {Dependency} dependency - The dependency to add
   */
  addDependency(dependency: Dependency): void
  /**
   * Update a dependency's version
   *
   * @param {string} name - The name of the dependency to update
   * @param {string} version - The new version of the dependency
   */
  updateDependencyVersion(name: string, version: string): void
  /**
   * Get a dependency by name
   *
   * @param {string} name - The name of the dependency to get
   * @returns {Dependency | null} A dependency or null if not found
   */
  getDependency(name: string): Dependency | null
  /**
   * Get the number of dependencies
   *
   * @returns {number} The number of dependencies
   */
  get dependencyCount(): number
  /**
   * Update dependencies based on a resolution result
   *
   * This method updates all dependencies in the package according to the
   * resolution result.
   *
   * @param {ResolutionResult} resolution - The resolution result to apply
   * @param {Env} env - The NAPI environment
   * @returns {Array<[string, string, string]>} Array of [name, oldVersion, newVersion] tuples for updated deps
   */
  updateDependenciesFromResolution(resolution: ResolutionResult): Array<[string, string, string]>
  /**
   * Check for dependency version conflicts in this package
   *
   * @param {DependencyRegistry} registry - The dependency registry to use
   * @returns {Array<[string, Array<string>]>} Map of dependency names to conflicting version requirements
   */
  findVersionConflicts(): Array<[string, Array<string>]>
  /**
   * Generate combined dependency information for all packages
   *
   * @param {Package[]} packages - Array of packages to analyze
   * @param {DependencyRegistry} registry - The dependency registry to use
   * @returns {DependencyInfo} Object with dependency information
   */
  static generateDependencyInfo(packages: Array<Package>): DependencyInfo
}

/**
 * JavaScript binding for ws_pkg::types::diff::PackageDiff
 * The complete diff between two package versions
 */
export declare class PackageDiff {
  /**
   * Create a new package diff between two packages
   *
   * @param {Package} previous - The previous package version
   * @param {Package} current - The current package version
   * @returns {PackageDiff} A diff of the changes between packages
   */
  static between(previous: Package, current: Package): PackageDiff
  /**
   * Get the package name
   *
   * @returns {string} The package name
   */
  get packageName(): string
  /**
   * Get the previous version
   *
   * @returns {string} The previous version
   */
  get previousVersion(): string
  /**
   * Get the current version
   *
   * @returns {string} The current version
   */
  get currentVersion(): string
  /**
   * Get dependency changes
   *
   * @returns {DependencyChange[]} The dependency changes
   */
  get dependencyChanges(): Array<DependencyChange>
  /**
   * Get whether this diff is a breaking change
   *
   * @returns {boolean} True if this is a breaking change (major version bump)
   */
  get breakingChange(): boolean
  /**
   * Count the number of breaking changes in dependencies
   *
   * @returns {number} The count of breaking changes
   */
  countBreakingChanges(): number
  /**
   * Count the changes by type
   *
   * @returns {Object} Map of change types to counts
   */
  countChangesByType(): Record<string, number>
  /**
   * Get a human-readable string representation of the diff
   *
   * @returns {string} A formatted string representation of the diff
   */
  toString(): string
}

/**
 * JavaScript binding for ws_pkg::PackageInfo
 * Represents a package with its metadata
 *
 * @class PackageInfo - The PackageInfo class.
 * @example
 *
 * ```typescript
 * const pkgInfo = new PackageInfo(package, "/path/to/package.json", "/path/to/package", "./relative/path", packageJson);
 * console.log(pkgInfo.packageJsonPath); // /path/to/package.json
 * ```
 */
export declare class PackageInfo {
  /**
   * Create a new package info object
   *
   * @param {Package} pkg - The package object
   * @param {string} packageJsonPath - Path to the package.json file
   * @param {string} packagePath - Path to the package directory
   * @param {string} packageRelativePath - Relative path to the package directory
   * @param {Object} packageJson - The package.json content
   * @returns {PackageInfo} The new package info
   */
  constructor(pkg: Package, packageJsonPath: string, packagePath: string, packageRelativePath: string, packageJson: object)
  /**
   * Get the package json path
   *
   * @returns {string} The path to package.json
   */
  get packageJsonPath(): string
  /**
   * Get the package path
   *
   * @returns {string} The path to the package
   */
  get packagePath(): string
  /**
   * Get the relative package path
   *
   * @returns {string} The relative path to the package
   */
  get packageRelativePath(): string
  /**
   * Get the package
   *
   * @returns {Package} The package
   */
  get package(): Package
  /**
   * Update the package version
   *
   * @param {string} newVersion - The new version to set
   * @returns {void}
   */
  updateVersion(newVersion: string): void
  /**
   * Update a dependency version
   *
   * @param {string} depName - The name of the dependency to update
   * @param {string} newVersion - The new version to set
   * @returns {void}
   */
  updateDependencyVersion(depName: string, newVersion: string): void
  /**
   * Apply dependency resolution across all packages
   *
   * @param {ResolutionResult} resolution - The resolution result to apply
   * @returns {void}
   */
  applyDependencyResolution(resolution: ResolutionResult): void
  /**
   * Write the package.json file to disk
   *
   * @returns {void}
   */
  writePackageJson(): void
  /**
   * Get the package.json content
   *
   * @returns {Object} The package.json content
   */
  get packageJson(): Result<string, unknown>
}

/** JavaScript binding for package registry interface */
export declare class PackageRegistry {
  /**
   * Create a new npm registry
   *
   * @param {string} baseUrl - The base URL for the npm registry
   * @returns {PackageRegistry} A new npm registry
   */
  static createNpmRegistry(baseUrl: string): PackageRegistry
  /**
   * Create a new local registry (for testing)
   *
   * @returns {PackageRegistry} A new local registry
   */
  static createLocalRegistry(): PackageRegistry
  /**
   * Get the latest version of a package
   *
   * @param {string} packageName - The name of the package
   * @returns {string | null} The latest version, or null if not found
   */
  getLatestVersion(packageName: string): string|null
  /**
   * Get all available versions of a package
   *
   * @param {string} packageName - The name of the package
   * @returns {string[]} Array of available versions
   */
  getAllVersions(packageName: string): string[]
  /**
   * Get metadata about a package
   *
   * @param {string} packageName - The name of the package
   * @param {string} version - The version to get info for
   * @returns {Object} Package metadata
   */
getPackageInfo(packageName: string, version: string): {package: Package,packageJsonPath: string,packagePath: string, pkgJson: Record<string, unknown>}
/**
 * Set authentication for the registry
 *
 * @param {RegistryAuthConfig} auth - The authentication configuration
 * @returns {void}
 */
setAuth(auth: RegistryAuthConfig): void
/**
 * Set the user agent string
 *
 * @param {string} userAgent - The user agent string
 * @returns {void}
 */
setUserAgent(userAgent: string): void
/**
 * Clear the registry cache
 *
 * @returns {void}
 */
clearCache(): void
/**
 * Add a package to a local registry (only works with local registries)
 *
 * @param {string} name - The package name
 * @param {string[]} versions - Array of versions to add
 * @returns {void}
 */
addPackage(name: string, versions: Array<string>): void
/**
 * Set dependencies for a specific package version in a local registry
 *
 * @param {string} name - The package name
 * @param {string} version - The version
 * @param {Object} dependencies - Map of dependency names to versions
 * @returns {void}
 */
setDependencies(name: string, version: string, dependencies: object): void
/**
 * Get all packages in a local registry
 *
 * @returns {string[]} Array of all package names
 */
getAllPackages(): string[]
}

/** JavaScript binding for registry manager */
export declare class RegistryManager {
  /**
   * Create a new registry manager
   *
   * @returns {RegistryManager} A new registry manager
   */
  constructor()
  /**
   * Add a registry
   *
   * @param {string} url - The registry URL
   * @param {RegistryType} registryType - The type of registry
   * @param {string} [clientName] - The client name for custom registries
   * @returns {void}
   */
  addRegistry(url: string, registryType: RegistryType, clientName?: string | undefined | null): void
  /**
   * Set authentication for a registry
   *
   * @param {string} registryUrl - The registry URL
   * @param {RegistryAuthConfig} auth - The authentication configuration
   * @returns {void}
   */
  setAuth(registryUrl: string, auth: RegistryAuthConfig): void
  /**
   * Associate a scope with a specific registry
   *
   * @param {string} scope - The package scope (with or without @ prefix)
   * @param {string} registryUrl - The registry URL
   * @returns {void}
   */
  associateScope(scope: string, registryUrl: string): void
  /**
   * Set the default registry
   *
   * @param {string} registryUrl - The registry URL
   * @returns {void}
   */
  setDefaultRegistry(registryUrl: string): void
  /**
   * Get the latest version of a package
   *
   * @param {string} packageName - The name of the package
   * @returns {string | null} The latest version, or null if not found
   */
  getLatestVersion(packageName: string): string|null
  /**
   * Get all available versions of a package
   *
   * @param {string} packageName - The name of the package
   * @returns {string[]} Array of available versions
   */
  getAllVersions(packageName: string): string[]
  /**
   * Get metadata about a package
   *
   * @param {string} packageName - The name of the package
   * @param {string} version - The version to get info for
   * @returns {Object} Package metadata
   */
getPackageInfo(packageName: string, version: string): {package: Package,packageJsonPath: string,packagePath: string, pkgJson: Record<string, unknown>}
/**
 * Load configuration from .npmrc file
 *
 * @param {string} [npmrcPath] - Optional path to .npmrc file
 * @returns {void}
 */
loadFromNpmrc(npmrcPath?: string | undefined | null): void
/**
 * Get the default registry URL
 *
 * @returns {string} The default registry URL
 */
get defaultRegistry(): string
/**
 * Check if a scope is associated with a registry
 *
 * @param {string} scope - The package scope
 * @returns {boolean} True if the scope is associated with a registry
 */
hasScope(scope: string): boolean
/**
 * Get the registry URL associated with a scope
 *
 * @param {string} scope - The package scope
 * @returns {string | null} The registry URL, or null if not found
 */
getRegistryForScope(scope: string): string | null
/**
 * Get all registry URLs
 *
 * @returns {string[]} Array of all registry URLs
 */
registryUrls(): Array<string>
/**
 * Add a registry instance directly
 *
 * @param {string} url - The registry URL
 * @param {PackageRegistry} registry - The registry instance
 * @returns {void}
 */
addRegistryInstance(url: string, registry: PackageRegistry): void
}

/** JavaScript binding for validation report */
export declare class ValidationReport {
  /**
   * Check if there are any issues in the report
   *
   * @returns {boolean} True if there are any issues
   */
  get hasIssues(): boolean
  /**
   * Check if there are any critical issues
   *
   * @returns {boolean} True if there are critical issues
   */
  get hasCriticalIssues(): boolean
  /**
   * Check if there are any warnings (non-critical issues)
   *
   * @returns {boolean} True if there are warnings
   */
  get hasWarnings(): boolean
  /**
   * Get all issues in the report
   *
   * @returns {ValidationIssueInfo[]} Array of validation issues
   */
  getIssues(): Array<ValidationIssueInfo>
  /**
   * Get critical issues only
   *
   * @returns {ValidationIssueInfo[]} Array of critical validation issues
   */
  getCriticalIssues(): Array<ValidationIssueInfo>
  /**
   * Get warnings only (non-critical issues)
   *
   * @returns {ValidationIssueInfo[]} Array of warning validation issues
   */
  getWarnings(): Array<ValidationIssueInfo>
}

/** JavaScript binding for version utilities */
export declare class VersionUtils {
  /** Bump a version to the next major version */
  static bumpMajor(version: string): string | null
  /** Bump a version to the next minor version */
  static bumpMinor(version: string): string | null
  /** Bump a version to the next patch version */
  static bumpPatch(version: string): string | null
  /** Bump a version to a snapshot version with the given SHA */
  static bumpSnapshot(version: string, sha: string): string | null
  /** Compare two version strings and return their relationship */
  static compareVersions(v1: string, v2: string): VersionComparisonResult
  /** Check if moving from v1 to v2 is a breaking change */
  static isBreakingChange(v1: string, v2: string): boolean
}

/** JavaScript binding for ws_pkg::upgrader::AvailableUpgrade */
export interface AvailableUpgrade {
  /** Package name containing the dependency */
  packageName: string
  /** Dependency name */
  dependencyName: string
  /** Current version of the dependency */
  currentVersion: string
  /** Latest available version that's compatible with requirements */
  compatibleVersion?: string
  /** Latest overall version (may not be compatible with current requirements) */
  latestVersion?: string
  /** Status of this dependency's upgradability */
  status: UpgradeStatus
}

/**
 * Build a dependency graph from package infos
 *
 * @param {PackageInfo[]} packageInfos - Array of package infos
 * @returns {DependencyGraph} The constructed dependency graph
 */
export declare function buildDependencyGraphFromPackageInfos(packageInfos: Array<PackageInfo>): DependencyGraph

/**
 * Build a dependency graph from packages
 *
 * @param {Package[]} packages - Array of packages to include in the graph
 * @returns {DependencyGraph} The constructed dependency graph
 */
export declare function buildDependencyGraphFromPackages(packages: Array<Package>): DependencyGraph

/** JavaScript binding for ws_pkg::bump::BumpOptions */
export interface BumpOptions {
  /** Git reference to start from */
  since?: string
  /** Explicitly bump to a specific version type */
  releaseAs?: Version
  /** Fetch all branches */
  fetchAll?: boolean
  /** Fetch tags */
  fetchTags?: boolean
  /** Synchronize dependencies */
  syncDeps?: boolean
  /** Push changes to remote */
  push?: boolean
}

/** Bump a package version to a snapshot version with the given SHA */
export declare function bumpSnapshotVersion(version: string, sha: string): NapiResult<string>

/** Bump a package version */
export declare function bumpVersion(version: string, bumpType: Version): NapiResult<string>

/** JavaScript binding for ws_pkg::types::diff::ChangeType enum */
export declare enum ChangeType {
  /** Package was added */
  Added = 0,
  /** Package was removed */
  Removed = 1,
  /** Package version was updated */
  Updated = 2,
  /** No change detected */
  Unchanged = 3
}

export declare function createDefaultUpgradeConfig(): UpgradeConfig

export declare function createUpgradeConfigFromStrategy(strategy: VersionUpdateStrategy): UpgradeConfig

export declare function createUpgradeConfigWithRegistries(registries: Array<string>): UpgradeConfig

/** JavaScript binding for ws_pkg::graph::DependencyFilter */
export declare enum DependencyFilter {
  /** Include only production dependencies */
  ProductionOnly = 0,
  /** Include production and development dependencies */
  WithDevelopment = 1,
  /** Include production, development, and optional dependencies */
  AllDependencies = 2
}

/** JavaScript binding for dependency update information */
export interface DependencyUpdateInfo {
  /** Package containing the dependency */
  packageName: string
  /** Dependency name */
  dependencyName: string
  /** Current version */
  currentVersion: string
  /** New version to update to */
  newVersion: string
}

/** JavaScript binding for ws_pkg::graph::visualization::DotOptions */
export interface DotOptions {
  /** Title of the graph */
  title: string
  /** Whether to include external (unresolved) dependencies */
  showExternal: boolean
  /** Whether to highlight circular dependencies */
  highlightCycles: boolean
}

/** JavaScript binding for ws_pkg::upgrader::config::ExecutionMode */
export declare enum ExecutionMode {
  /** Only report potential upgrades without applying them */
  DryRun = 0,
  /** Apply upgrades to packages */
  Apply = 1
}

/**
 * Generate an ASCII representation of the dependency graph
 *
 * @param {DependencyGraph} graph - The dependency graph to visualize
 * @returns {string} ASCII representation of the graph
 */
export declare function generateAscii(graph: DependencyGraph): string

/**
 * Generate DOT format representation of a dependency graph
 *
 * @param {DependencyGraph} graph - The dependency graph to visualize
 * @param {DotOptions} options - Options for generating the DOT output
 * @returns {string} DOT format graph representation
 */
export declare function generateDot(graph: DependencyGraph, options: DotOptions): string

export declare function getVersion(): string

/**
 * Parse a scoped package name with optional version and path
 *
 * Handles formats like:
 * - @scope/name
 * - @scope/name@version
 * - @scope/name@version@path
 * - @scope/name:version
 *
 * @param {string} pkg_name - The scoped package name to parse
 * @returns {Object | null} An object with parsed components or null if not a valid scoped package
 */
export declare function parseScopedPackage(pkgName: string): ScopedPackageInfo | null

/** JavaScript binding for registry authentication */
export interface RegistryAuthConfig {
  /** Auth token */
  token: string
  /** Token type (bearer, basic, etc) */
  tokenType: string
  /** Whether to always use this auth */
  always: boolean
}

/** JavaScript binding for registry types */
export declare enum RegistryType {
  /** npm registry */
  Npm = 0,
  /** GitHub packages registry */
  GitHub = 1,
  /** Custom registry */
  Custom = 2
}

/** JavaScript binding for DependencyResolutionError */
export declare enum ResolutionErrorType {
  /** Error parsing a version */
  VersionParseError = 0,
  /** Incompatible versions of the same dependency */
  IncompatibleVersions = 1,
  /** No valid version found */
  NoValidVersion = 2
}

/** JavaScript binding for the result of dependency resolution */
export interface ResolutionResult {
  /** Resolved versions for each package */
  resolvedVersions: object
  /** Dependencies that need updates */
  updatesRequired: Array<DependencyUpdateInfo>
}

/**
 * Save DOT output to a file
 *
 * @param {string} dotContent - The DOT content to save
 * @param {string} filePath - Path to save the file
 * @returns {void}
 */
export declare function saveDotToFile(dotContent: string, filePath: string): void

/** JavaScript binding for ws_pkg::upgrader::config::UpgradeConfig */
export interface UpgradeConfig {
  /** Which types of dependencies to include */
  dependencyTypes: DependencyFilter
  /** Which types of version updates to include */
  updateStrategy: VersionUpdateStrategy
  /** Whether to include prerelease versions */
  versionStability: VersionStability
  /** Specific packages to upgrade (if empty, upgrade all) */
  targetPackages: Array<string>
  /** Specific dependencies to upgrade (if empty, upgrade all) */
  targetDependencies: Array<string>
  /** Additional registries to check for updates */
  registries: Array<string>
  /** Whether to actually apply the upgrades or just report them */
  executionMode: ExecutionMode
}

/** JavaScript binding for ws_pkg::upgrader::status::UpgradeStatus */
export declare enum UpgradeStatus {
  /** Dependency is up to date */
  UpToDate = 0,
  /** Patch update available (0.0.x) */
  PatchAvailable = 1,
  /** Minor update available (0.x.0) */
  MinorAvailable = 2,
  /** Major update available (x.0.0) */
  MajorAvailable = 3,
  /** Version requirements don't allow update */
  Constrained = 4,
  /** Failed to check for updates */
  CheckFailed = 5
}

/** JavaScript binding for validation issue */
export interface ValidationIssueInfo {
  /** Type of the issue */
  issueType: ValidationIssueType
  /** Human-readable message describing the issue */
  message: string
  /** Whether this is a critical issue */
  critical: boolean
  /** Additional data for circular dependency */
  path?: Array<string>
  /** Additional data for unresolved dependency */
  dependencyName?: string
  /** Additional data for unresolved dependency */
  versionReq?: string
  /** Additional data for version conflict */
  conflictingVersions?: Array<string>
}

/** JavaScript binding for types of validation issues */
export declare enum ValidationIssueType {
  /** Circular dependency detected */
  CircularDependency = 0,
  /** Unresolved dependency */
  UnresolvedDependency = 1,
  /** Version conflict */
  VersionConflict = 2
}

/** JavaScript binding for ws_pkg::types::version::Version enum */
export declare enum Version {
  /** Major version bump */
  Major = 0,
  /** Minor version bump */
  Minor = 1,
  /** Patch version bump */
  Patch = 2,
  /** Snapshot version */
  Snapshot = 3
}

/** JavaScript binding for version relationship comparisons */
export declare enum VersionComparisonResult {
  /** Second version is a major upgrade (1.0.0 -> 2.0.0) */
  MajorUpgrade = 0,
  /** Second version is a minor upgrade (1.0.0 -> 1.1.0) */
  MinorUpgrade = 1,
  /** Second version is a patch upgrade (1.0.0 -> 1.0.1) */
  PatchUpgrade = 2,
  /** Moved from prerelease to stable (1.0.0-alpha -> 1.0.0) */
  PrereleaseToStable = 3,
  /** Newer prerelease version (1.0.0-alpha -> 1.0.0-beta) */
  NewerPrerelease = 4,
  /** Versions are identical (1.0.0 == 1.0.0) */
  Identical = 5,
  /** Second version is a major downgrade (2.0.0 -> 1.0.0) */
  MajorDowngrade = 6,
  /** Second version is a minor downgrade (1.1.0 -> 1.0.0) */
  MinorDowngrade = 7,
  /** Second version is a patch downgrade (1.0.1 -> 1.0.0) */
  PatchDowngrade = 8,
  /** Moved from stable to prerelease (1.0.0 -> 1.0.0-alpha) */
  StableToPrerelease = 9,
  /** Older prerelease version (1.0.0-beta -> 1.0.0-alpha) */
  OlderPrerelease = 10,
  /** Version comparison couldn't be determined (invalid versions) */
  Indeterminate = 11
}

/** JavaScript binding for ws_pkg::types::version::VersionStability */
export declare enum VersionStability {
  /** Only include stable versions */
  StableOnly = 0,
  /** Include prereleases and stable versions */
  IncludePrerelease = 1
}

/** JavaScript binding for ws_pkg::types::version::VersionUpdateStrategy */
export declare enum VersionUpdateStrategy {
  /** Only upgrade patch versions (0.0.x) */
  PatchOnly = 0,
  /** Upgrade patch and minor versions (0.x.y) */
  MinorAndPatch = 1,
  /** Upgrade all versions including major ones (x.y.z) */
  AllUpdates = 2
}
