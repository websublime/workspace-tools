//! Hook installer for setting up Git hooks
//!
//! The HookInstaller manages the installation, uninstallation, and status checking
//! of Git hooks in the repository, leveraging FileSystemManager for file operations.

use super::{HookDefinition, HookType};
use crate::core::MonorepoProject;
use crate::error::{Error, Result};
use std::collections::HashMap;
use std::path::{Path, PathBuf};
use std::sync::Arc;

/// Installer for Git hooks that manages hook files and permissions
pub struct HookInstaller {
    /// Reference to the monorepo project
    #[allow(dead_code)] // Will be used when full integration is implemented
    project: Arc<MonorepoProject>,

    /// Path to the Git hooks directory
    hooks_dir: PathBuf,

    /// Template for the hook script wrapper
    hook_template: String,
}

impl HookInstaller {
    /// Create a new hook installer
    ///
    /// # Errors
    /// Returns an error if:
    /// - The Git directory cannot be found
    /// - The hooks directory cannot be accessed
    pub fn new(project: Arc<MonorepoProject>) -> Result<Self> {
        let hooks_dir = Self::find_git_hooks_directory(&project)?;
        let hook_template = Self::get_hook_template();

        Ok(Self { project, hooks_dir, hook_template })
    }

    /// Install a specific Git hook
    ///
    /// # Errors
    /// Returns an error if:
    /// - The hook file cannot be created
    /// - Permissions cannot be set on the hook file
    /// - The hooks directory is not writable
    pub fn install_hook(&self, hook_type: &HookType, definition: &HookDefinition) -> Result<()> {
        if !definition.enabled {
            return Ok(());
        }

        let hook_filename = hook_type.git_hook_filename();
        let hook_path = self.hooks_dir.join(hook_filename);

        // Generate hook script content
        let script_content = self.generate_hook_script(hook_type, definition);

        // Write the hook file
        self.write_hook_file(&hook_path, &script_content)?;

        // Make the hook executable
        self.make_executable(&hook_path)?;

        Ok(())
    }

    /// Uninstall a specific Git hook
    ///
    /// # Errors
    /// Returns an error if the hook file cannot be removed
    pub fn uninstall_hook(&self, hook_type: &HookType) -> Result<bool> {
        let hook_filename = hook_type.git_hook_filename();
        let hook_path = self.hooks_dir.join(hook_filename);

        if hook_path.exists() {
            self.remove_hook_file(&hook_path)?;
            Ok(true)
        } else {
            Ok(false)
        }
    }

    /// Uninstall all hooks managed by this installer
    ///
    /// # Errors
    /// Returns an error if any hook file cannot be removed
    pub fn uninstall_all_hooks(&self) -> Result<Vec<HookType>> {
        let mut uninstalled = Vec::new();

        for hook_type in HookType::all() {
            if self.uninstall_hook(&hook_type)? {
                uninstalled.push(hook_type);
            }
        }

        Ok(uninstalled)
    }

    /// Get the installation status of all hooks
    ///
    /// # Errors
    /// Returns an error if the hooks directory cannot be read
    pub fn get_installation_status(&self) -> Result<HashMap<HookType, bool>> {
        let mut status = HashMap::new();

        for hook_type in HookType::all() {
            let hook_filename = hook_type.git_hook_filename();
            let hook_path = self.hooks_dir.join(hook_filename);
            let is_installed = self.is_hook_installed(&hook_path)?;
            status.insert(hook_type, is_installed);
        }

        Ok(status)
    }

    /// Check if a specific hook is installed and valid
    ///
    /// # Errors
    /// Returns an error if the file system cannot be accessed
    pub fn is_hook_installed(&self, hook_path: &Path) -> Result<bool> {
        if !hook_path.exists() {
            return Ok(false);
        }

        // Check if the file is executable
        let is_executable = self.is_executable(hook_path)?;
        if !is_executable {
            return Ok(false);
        }

        // Check if it's our hook (contains our marker)
        let content = self.read_hook_file(hook_path)?;
        Ok(content.contains("# Generated by sublime-monorepo-tools"))
    }

    /// Backup existing hooks before installation
    ///
    /// # Errors
    /// Returns an error if backup operations fail
    pub fn backup_existing_hooks(&self) -> Result<Vec<PathBuf>> {
        let mut backups = Vec::new();
        let backup_dir = self.hooks_dir.join("backups");

        // Create backup directory if it doesn't exist
        if !backup_dir.exists() {
            self.create_directory(&backup_dir)?;
        }

        for hook_type in HookType::all() {
            let hook_filename = hook_type.git_hook_filename();
            let hook_path = self.hooks_dir.join(hook_filename);

            if hook_path.exists() {
                let backup_name =
                    format!("{}.backup.{}", hook_filename, chrono::Utc::now().timestamp());
                let backup_path = backup_dir.join(backup_name);

                self.copy_file(&hook_path, &backup_path)?;
                backups.push(backup_path);
            }
        }

        Ok(backups)
    }

    /// Restore hooks from backup
    ///
    /// # Errors
    /// Returns an error if restore operations fail
    pub fn restore_from_backup(&self, backup_paths: &[PathBuf]) -> Result<()> {
        for backup_path in backup_paths {
            if let Some(filename) = backup_path.file_name() {
                let filename_str = filename.to_string_lossy();
                if let Some(original_name) = filename_str.split('.').next() {
                    let original_path = self.hooks_dir.join(original_name);
                    self.copy_file(backup_path, &original_path)?;
                    self.make_executable(&original_path)?;
                }
            }
        }

        Ok(())
    }

    // Private helper methods

    /// Find the Git hooks directory for the repository
    fn find_git_hooks_directory(project: &MonorepoProject) -> Result<PathBuf> {
        // This would use the repository information from the project
        // For now, assume standard .git/hooks location
        let repo_root = project.root_path();
        let git_dir = repo_root.join(".git");

        if !git_dir.exists() {
            return Err(Error::hook("Git directory not found"));
        }

        let hooks_dir = git_dir.join("hooks");
        if !hooks_dir.exists() {
            return Err(Error::hook("Git hooks directory not found"));
        }

        Ok(hooks_dir)
    }

    /// Get the template for hook scripts
    fn get_hook_template() -> String {
        r#"#!/bin/sh
# Generated by sublime-monorepo-tools
# This hook is managed by the monorepo tools system

# Exit on any error
set -e

# Change to repository root
cd "$(git rev-parse --show-toplevel)"

# Execute the monorepo hook manager
exec sublime-monorepo-tools hook execute {hook_type} "$@"
"#
        .to_string()
    }

    /// Generate the hook script content for a specific hook type
    fn generate_hook_script(&self, hook_type: &HookType, _definition: &HookDefinition) -> String {
        self.hook_template.replace("{hook_type}", hook_type.git_hook_filename())
    }

    /// Write hook file content to disk
    #[allow(clippy::unused_self)]
    fn write_hook_file(&self, path: &Path, content: &str) -> Result<()> {
        // Use standard fs for hook file operations - simple and synchronous
        std::fs::write(path, content)
            .map_err(|e| Error::hook(format!("Failed to write hook file: {e}")))?;
        Ok(())
    }

    /// Remove a hook file
    #[allow(clippy::unused_self)]
    fn remove_hook_file(&self, path: &Path) -> Result<()> {
        // Use standard fs for hook file operations - simple and synchronous
        std::fs::remove_file(path)
            .map_err(|e| Error::hook(format!("Failed to remove hook file: {e}")))?;
        Ok(())
    }

    /// Read hook file content
    #[allow(clippy::unused_self)]
    fn read_hook_file(&self, path: &Path) -> Result<String> {
        // Use standard fs for hook file operations - simple and synchronous
        std::fs::read_to_string(path)
            .map_err(|e| Error::hook(format!("Failed to read hook file: {e}")))
    }

    /// Make a file executable
    #[allow(clippy::unused_self)]
    fn make_executable(&self, path: &Path) -> Result<()> {
        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            let mut perms = std::fs::metadata(path)
                .map_err(|e| Error::hook(format!("Failed to get file permissions: {e}")))?
                .permissions();
            perms.set_mode(0o755);
            std::fs::set_permissions(path, perms)
                .map_err(|e| Error::hook(format!("Failed to set file permissions: {e}")))?;
        }

        #[cfg(windows)]
        {
            // On Windows, files are executable by default for .bat/.cmd files
            // Git for Windows handles hook execution differently
            // Create a .bat wrapper if needed
            if let Some(extension) = path.extension().and_then(|ext| ext.to_str()) {
                if !extension.eq_ignore_ascii_case("bat") && !extension.eq_ignore_ascii_case("cmd")
                {
                    let bat_path = path.with_extension("bat");
                    let wrapper_content = format!(
                        "@echo off\nbash \"{}\" %*\n",
                        path.to_string_lossy().replace('\\', "/")
                    );
                    std::fs::write(&bat_path, wrapper_content).map_err(|e| {
                        Error::hook(format!("Failed to create Windows hook wrapper: {e}"))
                    })?;
                }
            }
        }

        Ok(())
    }

    /// Check if a file is executable
    #[allow(clippy::unused_self)]
    fn is_executable(&self, path: &Path) -> Result<bool> {
        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            let metadata = std::fs::metadata(path)
                .map_err(|e| Error::hook(format!("Failed to get file metadata: {e}")))?;
            let mode = metadata.permissions().mode();
            Ok(mode & 0o111 != 0) // Check if any execute bit is set
        }

        #[cfg(windows)]
        {
            // On Windows, check if file exists and is a valid executable or has .bat/.cmd extension
            if !path.exists() {
                return Ok(false);
            }

            if let Some(extension) = path.extension().and_then(|ext| ext.to_str()) {
                Ok(extension.eq_ignore_ascii_case("bat")
                    || extension.eq_ignore_ascii_case("cmd")
                    || extension.eq_ignore_ascii_case("exe"))
            } else {
                // Check if corresponding .bat file exists
                Ok(path.with_extension("bat").exists())
            }
        }
    }

    /// Create a directory
    #[allow(clippy::unused_self)]
    fn create_directory(&self, path: &Path) -> Result<()> {
        std::fs::create_dir_all(path)
            .map_err(|e| Error::hook(format!("Failed to create directory: {e}")))?;
        Ok(())
    }

    /// Copy a file
    #[allow(clippy::unused_self)]
    fn copy_file(&self, from: &Path, to: &Path) -> Result<()> {
        std::fs::copy(from, to).map_err(|e| Error::hook(format!("Failed to copy file: {e}")))?;
        Ok(())
    }
}
